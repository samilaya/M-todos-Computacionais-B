# -*- coding: utf-8 -*-
"""Trabalho2- Pêndulo caótico.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r9s4Bn-QAZHf9oOB10xUAVEBteGta2lj
"""

import numpy as np
import matplotlib.pyplot as plt

#Parametros

Valores_F = np.arange(0.4,1.1,0.1)
hp = 0.01  
cp = 0.05 
wp = 0.7
tfp = 10000
x0p = 1
v0p = 0

#dx/dt neste caso trata-se da velocidade angular
def func(t,x,v):
    return -cp*v - np.sin(x) + F*np.cos(wp*t)

def lim_dom(x):
    '''
        Recebe um array e limita o 
        dominio dos valores entre -pi e pi 
    '''
    x = x%(2*np.pi)
    if np.pi < x <= 2*np.pi: #como não temos angulos negativos não devemos preocuparnos com resto negativo
        x = x - 2*np.pi
    return x

def poincare(t,x,v):
    '''
        Recebe os array de t,x,e,v
        Guarda os valores de x e y para tempos divisiveis por el periodo T  
    '''

    x_care = []
    v_care = []
    T = 2*np.pi/wp
    for i in range(len(t)):
        resto = t[i]%T
        if resto < 0.01:
            x_care.append(x[i])
            v_care.append(v[i])
    return np.array(x_care), np.array(v_care)


def Rk_4(h,t_final,x0,v0):
#implementação do Rk4
    Npassos = int((t_final+h)/h)
    t,x,xlim,v = np.zeros(Npassos), np.zeros(Npassos),np.zeros(Npassos),np.zeros(Npassos)
    x[0], v[0] = x0, v0
    k1_v,k1_x,k2_v,k2_x,k3_v,k3_x,k4_v,k4_x = np.zeros(Npassos), np.zeros(Npassos),np.zeros(Npassos),np.zeros(Npassos),np.zeros(Npassos),np.zeros(Npassos),np.zeros(Npassos),np.zeros(Npassos)
    
    for i in range((Npassos-1)):
        #K1
        k1_x[i] = h*v[i]
        k1_v[i] = h*func(t[i],x[i],v[i])

        #k2
        tm = t[i] + 0.5*h
        xm1 = x[i] + 0.5*k1_x[i]
        vm1 = v[i] + 0.5*k1_v[i]
    

        k2_x[i] = h*vm1
        k2_v[i] = h*func(tm,xm1,vm1)

        #k3
        tm = t[i] + 0.5*h
        xm2 = x[i] + 0.5*k2_x[i]
        vm2 = v[i] + 0.5*k2_v[i]


        k3_x[i] = h*vm2
        k3_v[i] = h*func(tm,xm2,vm2)

        #k4
        t[i+1] = t[i] + h
        xm3 = x[i] + k3_x[i]
        vm3 = v[i] + k3_v[i]
    

        k4_x[i] = h*vm3                         
        k4_v[i] = h*func(t[i+1],xm3,vm3)        

    #Novos valores de x e v

        x[i+1] =  x[i] + 1 / 6 * (k1_x[i] + 2 * k2_x[i] + 2 * k3_x[i] + k4_x[i])
        v[i+1] =  v[i] + 1 / 6 * (k1_v[i] + 2 * k2_v[i] + 2 * k3_v[i] + k4_v[i])
    
    return (t,x,v)

fig, axs = plt.subplots(len(Valores_F),3, sharey=True, figsize=(18, 38))
tickslista0 = [r'$0$',r'$10\pi$',r'$20\pi$']
tickslista0y = [r'',r'0',r'']
tickslista1 = [r'$-\pi$',r'$0$',r'$\pi$']
L = 0

for valor in Valores_F:
    F = valor                           #Selecina cada valor de F para plotar os graficos
    Label = ('F = {:.1f}'.format(F))
    t,x,v = Rk_4(hp,tfp,x0p,v0p)
    ti = int(2000/hp)                   #tempo para regularizar todas as ondas
    t,x,v = t[ti:],x[ti:],v[ti:]        #valores sem o tempo inicial
    for i in range(len(x)):
        x[i] = lim_dom(x[i])            #limita o dominio de x 

    x_care,v_care = poincare(t,x,v)     #dalva os valores do poincare


    #graficos w vs t
    axs[L,0].plot(t,v, color ='lightseagreen', label = Label)
    axs[L,0].set_xlim(2000, 2000 + 20*np.pi)
    x0 = np.array([2000,2000+10*np.pi,2000+20*np.pi])
    y0 = np.array([-4,0,4])
    axs[L,0].set_xticks(x0)
    axs[L,0].set_yticks(y0)
    axs[L,0].set_xticklabels(tickslista0, minor=False)
    axs[L,0].legend()
    axs[-1,0].set_xlabel(r"Time t' ")

    #graficos w vs x
    axs[0,1].set_title('Phase-space')
    axs[L,1].scatter(x,v, 0.5, color ='lightseagreen',label = Label)
    axs[L,1].set_xlim(-np.pi, np.pi)
    x1 = np.array([-np.pi,0,np.pi])
    axs[L,1].set_xticks(x1)
    axs[L,1].set_yticks(y0)
    axs[L,1].set_xticklabels(tickslista1, minor=False) 
    axs[L,1].legend()
    axs[-1,1].set_xlabel(r"Angle x")
    
    #graficos w vs x - poincaré
    axs[0,2].set_title('Poincaré-Section')
    axs[L,2].scatter(x_care, v_care, color ='lightseagreen', label = Label)
    axs[L,2].set_xlim(-np.pi, np.pi)
    x1 = np.array([-np.pi,0,np.pi])
    axs[L,2].set_xticks(x1)
    axs[L,2].set_yticks(y0)
    axs[L,2].set_xticklabels(tickslista1, minor=False)    
    axs[L,2].legend()
    axs[-1,2].set_xlabel("Angle x")
    L+=1

plt.savefig("Alexandra_Soto_00309698_trabalho2.pdf")
plt.show()